\subsubsection{Mittels Touchgesten mit virtuellen Objekten interagieren}
\begin{description}
	\item[Fragestellung:] Wie kann mit Touch- und Swipegesten mit virtuellen Objekten interagiert werden?
	\item[Resultat:] Es konnte erfolgrich ein Prototyp entwickelt werden, bei dem es Möglich ist mittels verschiedenen Gesten mit einem virtuellen Objekt zu interagieren. Eine besondere Schwierigkeit bestand darin das Element zu kippen da je nach Kameraperspektive um die Z- oder X Achse gedreht werden muss. 
    \item[Versuchsaufbau:] Für diesen Versuch wurde ein neues XCode Projekt initialisiert. Anschliessend wurde die Logik implementiert um einen Würfel auf einer Fläche zu augmentieren. Es wurde die Funktionalität entwickelt mittels verschiedenen Gesten mit dem Würfel zu interagieren. Zu den funktionalitäten gehören:
    
    
    \begin{itemize}
        \item \texttt{UITapGestureRecognizer} mit einmaligem Tippen
        \item \texttt{UITapGestureRecognizer} mit zweimaligem Tippen
        \item \texttt{UILongPressGestureRecognizer} für langes antippen eines Objektes
        \item \texttt{UISwipeGestureRecognizer} für die Rotationen
    \end{itemize}


    \textbf{\texttt{UITapGestureRecognizer} mit einmaligem Tippen}\label{textbf:tap-gesture-recognizer}\\
    Damit mit Touchgesten gearbeitet werden kann müssen diese der SceneView hinzugefügt werden Code \ref{code:prot-gesture-addTapGestureToSceneView}. Für einzelne Taps können wir den \texttt{UITapGestureRecognizer} initialisieren und als action parameter eine Methode angeben. Wir geben hierfür die Methode \texttt{ViewController.didTap(withGestureRecognizer:)}. Zusätzlich sollte die Anzahl benötigter Taps mit \texttt{tapGestureRecognizer.numberOfTapsRequired} auf Eins gesetzt werden, da wir auch einen DoubleTap erkennen wollen. 
    \begin{code}{prot-gesture-addTapGestureToSceneView}{Methode \texttt{addTapGestureToSceneView()} um das einmalige antippen der \texttt{SceneView} hinzuzufügen}
    func addTapGestureToSceneView() {
        let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(ViewController.didTap(\_:)))
        tapGestureRecognizer.numberOfTapsRequired = 1
        sceneView.addGestureRecognizer(tapGestureRecognizer)
    }
    \end{code}

    Sollte erfolgreich ein Tap auf der SceneView registriert werden, so wird die Methode \texttt{didTap(\_ recognizer: UIGestureRecognizer)} im Code \ref{code:prot-gesture-didTap} ausgeführt. Bei dieser Methode werden die 2D Koordinaten des Taps ausgelesen und anschliesend an einem \texttt{hitTest(\_:types:)} im 3D Raum weitergegeben. Dieser HitTest prüft ob es sich um ein SceneKit Node handelt. Falls dies der Fall ist wird dieses Element selektiert und als interagierbares Objekt gesetzt. Dies geschied mir der Methode \texttt{updateSelectedObject(node: node)} aus dem Code \ref{code:prot-gesture-updateSelectedObject}. In diesem Code abschnitt werden auch zwei \texttt{SCNTransaction} ausgeführt damit der Benutzer anhand einer Visuellen animation erkennt welches das aktuell selektierte Objekt ist. Mittels \texttt{SCNTransaction} können komplexe Animationen erstellt werden und innerhalb einer Transaktion ausgeführt werden.

    \begin{code}{prot-gesture-didTap}{Methode \texttt{didTap(\_ recognizer: UIGestureRecognizer)} die beim einmaligen antippen der \texttt{SceneView} ausgeführt wird}
    @objc
    func didTap(_ recognizer: UIGestureRecognizer) {
        let tapLocation = recognizer.location(in: sceneView)
        let hitTestOptions: [SCNHitTestOption: Any] = [.boundingBoxOnly: true]
        let hitTestResults = sceneView.hitTest(tapLocation, options: hitTestOptions)

        guard let node = hitTestResults.first?.node else {return}
        
        updateSelectedObject(node: node)
    }
    \end{code}

    \begin{code}{prot-gesture-updateSelectedObject}{Methode \texttt{updateSelectedObject(node: node)} zur aktualisierung des ausgewählten Objekts}
    func updateSelectedObject(node: SCNNode) {
        // reset color of old selected object
        SCNTransaction.begin()
        SCNTransaction.animationDuration = 0.5
        selectedObject?.geometry?.firstMaterial?.diffuse.contents = UIColor(red: 182.0 / 255.0, green: 155.0 / 255.0, blue: 76.0 / 255.0, alpha: 1)
        SCNTransaction.commit()
        
        // Set new selected node
        selectedObject = node
        
        // Set selected color
        SCNTransaction.begin()
        SCNTransaction.animationDuration = 0.5
        selectedObject?.geometry?.firstMaterial?.diffuse.contents = UIColor(red: 130.0 / 255.0, green: 82.0 / 255.0, blue: 1.0 / 255.0, alpha: 1)
        SCNTransaction.commit()
    }
    \end{code}

    \textbf{\texttt{UITapGestureRecognizer} mit zweimaligem Tippen}\\
    Das zweimalige Antippen der SeceneView setzt einen neuen Würfel. Das Prinzip um das zweimalige Antippen zu registriern ist gleich wie im obigen Abschnitt "`\texttt{UITapGestureRecognizer} mit einmaligem Tippen"' ausser das wir die \texttt{doubleTapGestureRecognizer.numberOfTapsRequired} auf zwei erhöhen:
    \mint[style=xcode,breaklines]{swift}{doubleTapGestureRecognizer.numberOfTapsRequired = 2}

    Als auszuführende Methode wird \texttt{didDoubleTap(\_ recognizer: UIGestureRecognizer)} gesetzt. Bei der dieser Methode (Code \ref{code:prot-gesture-didDoubleTap}) wird wie beim einfachen Antippen geprüft on ein SeceneKit objekt beim HitTest getroffen wird. Ist dies nicht der Fall können wir den neuen Würfel platzieren. Dies wird mit der Methode \texttt{addBox(x: translation.x, y: translation.y, z: translation.z)} gemacht. Die Koordinaten des HitTest werden hierfür von einer Matrizen zu x, y, z konvertiert. Dies wurde anhand einer Extension gemacht Code \ref{code:prot-gesture-extension}

    \begin{code}{prot-gesture-didDoubleTap}{Methode \texttt{didDoubleTap(\_ recognizer: UIGestureRecognizer)} die beim zweimaligen Antippen der \texttt{SceneView} ausgeführt wird}
    @objc
    func didDoubleTap(_ recognizer: UIGestureRecognizer) {
        let tapLocation = recognizer.location(in: sceneView)
        let hitTestResults = sceneView.hitTest(tapLocation)
        
        guard let node = hitTestResults.first?.node else {
            let hitTestResultWithFeaturePoints = sceneView.hitTest(tapLocation, types: .estimatedHorizontalPlane)
            if let hitTestResultWithFeaturePoints = hitTestResultWithFeaturePoints.first {
                let translation = hitTestResultWithFeaturePoints.worldTransform.translation
                addBox(x: translation.x, y: translation.y, z: translation.z)
            }
            return
        }
    }
    \end{code}

    \begin{code}{prot-gesture-extension}{Extension funktion einer float4x4 Matrize um die Koordinaten in x, y und z zurückzugeben}
    // Helper function to convert a matrix to float3 -> x,y,z
    extension float4x4 {
        var translation: float3 {
            let translation = self.columns.3
            return float3(translation.x, translation.y, translation.z)
        }
    }
    \end{code}

    \textbf{\texttt{UILongPressGestureRecognizer} für langes antippen eines Objektes}\\
    Die neu erstellten Würfel sollten auch wieder gelöscht werden können. Um diese Verhalten möglichst Nutzerfreundlich zu gestalten kann lange auf ein Würfel getippt werden. Die Umsetzung erfolgt mit dem \texttt{UILongPressGestureRecognizer}. Der \texttt{UILongPressGestureRecognizer} muss wie bei den obigen Beispielen der SceneView hinzugefügt werden.

    \begin{code}{prot-gesture-addLongTapGestureToSceneView}{Methode \texttt{addLongTapGestureToSceneView()} um das lange antippen der \texttt{SceneView} hinzuzufügen}
    func addLongTapGestureToSceneView() {
        let longTapGestureRecognizer = UILongPressGestureRecognizer(target: self, action: #selector(ViewController.didLongPress(\_:)))
        sceneView.addGestureRecognizer(longTapGestureRecognizer)
    }
    \end{code}

    Wird ein \texttt{UILongPressGestureRecognizer} Event registriert so wird die Funktion \texttt{didLongPress(\_ recognizer: UILongPressGestureRecognizer)} (Code \ref{code:prot-gesture-addLongTapGestureToSceneView}) aufgerufen. Hier findet wie bei den obigen Beispielen ein HitTest statt. Sollte sich an der lang angetippten Stelle ein Würfel befinden so wird dieser mit der Methode \texttt{node.removeFromParentNode()} der SceneView entfernt.

    \begin{code}{prot-gesture-didLongPress}{Methode \texttt{didLongPress()}, die bei einem langen Antippen ausgeführt wird}
    @objc
    func didLongPress(\_ recognizer: UILongPressGestureRecognizer) {
        let longPressLocation = recognizer.location(in: sceneView)
        let hitTestResults = sceneView.hitTest(longPressLocation)
        
        guard let node = hitTestResults.first?.node else { return }
        node.removeFromParentNode()
    }
    \end{code}
    
    \textbf{\texttt{UISwipeGestureRecognizer} für die Rotationen}\\
    Damit die Rotation eines Würfels möglichst einfach wird wurde dies mit Wischgeste umgesetzt. Damit die Wischgeste für links, rechts, oben und untern funktioniert benötigt es vier \texttt{UISwipeGestureRecognizer}. Im Code \ref{code:prot-gesture-addSwipeGestureToSceneView} werden die vier \texttt{UISwipeGestureRecognizer} initialisiert. Wichtig hierbei ist es, dass jeweils die Richtig der Wischgeste mittels \texttt{swipeRightGesture.direction} gesetzt wird. Als auszuführende Aktion wird jeweils die Methode \texttt{didSwipe(\_:)} angegeben.

    \begin{code}{prot-gesture-addSwipeGestureToSceneView}{Methode \texttt{addSwipeGestureToSceneView()} um die Wischgesten nach links, rechts, unten und oben der \texttt{SceneView} hinzuzufügen}
        func addSwipeGestureToSceneView() {
            let swipeRightGesture = UISwipeGestureRecognizer(target: self, action: #selector(didSwipe(_:)))
            swipeRightGesture.direction = .right
            
            let swipeLeftGesture = UISwipeGestureRecognizer(target: self, action: #selector(didSwipe(_:)))
            swipeLeftGesture.direction = .left
            
            let swipeUpGesture = UISwipeGestureRecognizer(target: self, action: #selector(didSwipe(_:)))
            swipeUpGesture.direction = .up
            
            let swipeDownGesture = UISwipeGestureRecognizer(target: self, action: #selector(didSwipe(_:)))
            swipeDownGesture.direction = .down
            
            sceneView.addGestureRecognizer(swipeLeftGesture)
            sceneView.addGestureRecognizer(swipeRightGesture)
            sceneView.addGestureRecognizer(swipeUpGesture)
            sceneView.addGestureRecognizer(swipeDownGesture)
        }
    \end{code}

    \textbf{Drehen von Würfeln anhand der akutellen Kameraposition}\\
    Beim Drehen der Würfel bestehn zwei Schwierigkeiten. Einerseits muss der Würfel immer relativ zur Kamera nach ob oder unten gekippt werden. Es muss also entschieden werden ob die Rotation zur X-Achse oder Z-Achse erfolgt. Zusätzlich dreht beim rotieren eines Würfels das relative Koordinatensystem mit. Dies bedeutet dass bedeutet dem Kippen eine links Wischgeste den Würfel ebenfalls kippen würde.

    Das erste Problem kann gelöst werden indem anhand der aktuellen Kameraposition die Y-Achse ausgewertet wird. Je nach Winkel kann somit entschieden werden um welche Achse der Würfel sich drehen sollte. %TODO: HIER NOCH EIN BILD EINFÜGEN

    Das zweite Problem kann mittels Überschreiben des relativen Würfelkoordinatensystems gelöst werden. Nach der Rotation muss das relative Koordinatensystem des Würfels mit dem der Ausrichtig des World Origin überschrieben werden (Code \ref{code:prot-gesture-didSwipe} Zeile 29).

    \begin{code}{prot-gesture-didSwipe}{Methode \texttt{didSwipe(\_ gesture: UISwipeGestureRecognizer)} die beim Wischgesten nach links, rechts, unten und oben der \texttt{SceneView} ausgeführt wird}
    @objc
    func didSwipe(_ gesture: UISwipeGestureRecognizer) {
        let currentAngle = sceneView.session.currentFrame?.camera.eulerAngles.y
        var action: SCNAction!
        
        if gesture.direction == .right {
            action = SCNAction.rotateBy(x: 0, y: CGFloat(Double.pi/2), z: 0, duration: 0.5)
        }
        else if gesture.direction == .left {
            action = SCNAction.rotateBy(x: 0, y: CGFloat(-(Double.pi/2)), z: 0, duration: 0.5)
        }
        else if gesture.direction == .up {
            if (currentAngle! > Float(0.785) && currentAngle! < Float(2.356)) {
                action = SCNAction.rotateBy(x: 0, y: 0, z: CGFloat(Double.pi/2), duration: 0.5)
            }
            else if (currentAngle! > Float(2.356) || currentAngle! < Float(-2.356)) {
                action = SCNAction.rotateBy(x: CGFloat(Double.pi/2), y: 0, z: 0, duration: 0.5)
            }
            else if (currentAngle! > Float(-2.356) && currentAngle! < Float(-0.785)) {
                action = SCNAction.rotateBy(x: 0, y: 0, z: CGFloat(-(Double.pi/2)), duration: 0.5)
            }
            else if (currentAngle! > Float(-0.785) && currentAngle! < Float(0.785)) {
                action = SCNAction.rotateBy(x: CGFloat(-(Double.pi/2)), y: 0, z: 0, duration: 0.5)
            }
        }
        ...
        if action != nil {
            selectedObject?.runAction(action, forKey: "rotate")
            selectedObject?.orientation = SCNQuaternion(x: 0.0, y: 0.0, z: 0.0, w: 1.0)
        }
    }
    \end{code} 

\end{description}    
